<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>sciencenet</title>
      <link href="/2019/04/19/sciencenet/"/>
      <url>/2019/04/19/sciencenet/</url>
      
        <content type="html"><![CDATA[<p>ssr客户端下载：<br><a href="https://github.com/shadowsocksrr/shadowsocksr-csharp/releases" target="_blank" rel="noopener">https://github.com/shadowsocksrr/shadowsocksr-csharp/releases</a><br>节点网站（通过ssr客户端选取）：<br><a href="https://free-ss.site/" target="_blank" rel="noopener">https://free-ss.site/</a></p><p>clushx for window下载:<br><a href="https://github.com/Fndroid/clash_for_windows_pkg" target="_blank" rel="noopener">https://github.com/Fndroid/clash_for_windows_pkg</a><br>节点配置文件：<br><a href="https://api.loxcloud.com/ss/orders/101707/clashSub?port=17069&amp;passwd=VngBvFnH" target="_blank" rel="noopener">https://api.loxcloud.com/ss/orders/101707/clashSub?port=17069&amp;passwd=VngBvFnH</a><br>配置教程：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/net/clash%20for%20win%E9%85%8D%E7%BD%AE.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Personal Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux中的vim操作</title>
      <link href="/2019/03/10/linux-zhong-de-vim-cao-zuo/"/>
      <url>/2019/03/10/linux-zhong-de-vim-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p>基本命令：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/linux/vim_cmd.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两数之和</title>
      <link href="/2019/03/10/liang-shu-zhi-he/"/>
      <url>/2019/03/10/liang-shu-zhi-he/</url>
      
        <content type="html"><![CDATA[<p><strong>问题描述：</strong><br>        给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，返回的两个下标不能相同，即不能为相同的一个元素。<br>示例：<br>        给定 nums = [2, 7, 11, 15], target = 9<br>        因为 nums[0] + nums[1] = 2 + 7 = 9<br>        所以返回 [0, 1]</p><p><strong>思路一（暴力法）：</strong><br>        遍历每个元素 x，并查找是否存在一个值与 target - x 相等的目标元素。显然是需要两个迭代，使用C编写。<br><strong>code:</strong></p><pre><code>int* twoSum(int* nums, int numsSize, int target) {    static int a[2] = {0};    int i,j;    i = j = 0;    for(i = 0;i &lt; numsSize;i++)    {        for(j = i+1;j &lt; numsSize;j++)        {            if(nums[i] + nums[j] == target)            {                a[0] = i;                a[1] = j;                return a;            }        }    }    return 0;}</code></pre><p>复杂度：<br>       时间复杂度：O(n^2)；            空间复杂度：O(1)</p><p><strong>思路二：</strong><br>        对于上述问题，我们可以优化其时间复杂度，在查找数组中是否存在满足目标值的迭代中，我们可以利用哈希表的特点，能够使索引与数据一一对应，这样我们查找目标值时，时间复杂度可以由O(n)变为O(1)(当然是理想状况下，由于hash map还存在冲突等问题，并不能完全达到O(1)的时间，但其效率还是要远远大于O(n))。由于用C编写hashmap较复杂，所以这里我们用Python编写，用其中的’字典’来存储数据，因为字典背后的原理就是一个散列表。在进行迭代并将元素插入到表中的同时(元素不在表中)，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。<br><strong>code：</strong></p><pre><code>class Solution:    def twoSum(self,nums,target):        length = len(nums)        key = {}        for i in range(length):            new_n = target - nums[i];    #用于判断当前值对应的目标元素是否在新字典里            if new_n in key:                return [key[new_n],i]       #目标元素在新字典中，直接返回其下标            if nums[i] not in key:                key[nums[i]] = i            #目标元素不在新字典中，将当前值存储到新字典中，用于后面原字典数据的判断</code></pre><p>复杂度：<br>      因为只使用了一个迭代，故时间复杂度O(n)；同样的，因为用新字典key{}存储已经判断过的值，即我们是通过空间的提升换取时间效率的提升，所以空间复杂度由O(1)变为O(n)。</p>]]></content>
      
      
      <categories>
          
          <category> Programming Thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 求和算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无重复字符的最长子串</title>
      <link href="/2019/03/10/wu-chong-fu-zi-fu-de-zui-chang-zi-chuan/"/>
      <url>/2019/03/10/wu-chong-fu-zi-fu-de-zui-chang-zi-chuan/</url>
      
        <content type="html"><![CDATA[<p><strong>问题描述：</strong><br>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p><p>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p><p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p><p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是子串的长度，”pwke” 是一个子序列，不是子串。</p><p><strong>思路一(暴力法)：</strong><br>    要找出无重复的最长子串，我们可以采用最直接的办法，先利用两个迭代给出所有可能的子串组合，然后我们建立一个判断字符串中每个字符是否唯一的函数就可以解决(字符串唯一，则返回true并求其长度。不唯一，则返回false)。其中allUnique()函数，使用集合形式去判断，利用集合元素必须唯一的特性，每当向集合中加入一个字符时，我们先判断其是否存在，若存在，则子串不唯一。遍历结束，就可以得出结论。<br><strong>code：</strong></p><pre><code>class Solution {public:    int lengthOfLongestSubstring(string s) {        int n = s.length();        int ans = 0;        for(int i = 0;i &lt; n;i++)            for(int j = i+1;j &lt;= n ;j++) //注意这里i、j的结束值，共n个字符，j可以取到n是用于allUnique()，这样才能取到所有组合                if(allUnique(s,i,j))                    ans = max(ans,j-i);        return ans;    }public:    bool allUnique(string s,int start,int end)    {        set&lt;char&gt; t;        for(int i =start; i &lt; end;i++)        {            if(t.find(s[i]) == t.end())                t.insert(s[i]);            else                return false;        }        return true;    }};</code></pre><p><strong>时间复杂度：</strong><br> 通过遍历给出所有可能的子串组合的时间复杂度为O(n^2)，而判断子串是否唯一的函数一次遍历需要O(J-I)，故总时间复杂度为O(n^3)；<br>空间复杂度的大小为集合所占用空间的大小，取决于字符串n和最长子串m的大小，为O(min(n,m))。</p><p><strong>思路二(滑动窗口)：</strong><br>    暴力法中，我们会对每一个子串的所有字符进行判读是否存在重复字符，但实际上并非必要。试想一下，假设字符串s的一个子串s[i]~s<a href="下标为 i ~ j-1">j-1</a>已经判断为无重复子串，那么此时我们再判断和这个相关的子串s[i] ~ s[j]，我们只需要判断s[j]这一个字符是否已经存在于s[i]~s[j-1]即可，而不是再对这一个子串的所有字符进行判断。<br>    要检查一个字符是否已经在子字符串中，我们可以检查整个子字符串，这将产生一个复杂度为 O(n^2)的算法，但我们可以做得更好。通过使用HashSet 作为滑动窗口，我们可以用 O(1) 的时间来完成对字符是否在当前的子字符串中的检查。<strong>滑动窗口</strong>是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i, j)（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 [i, j)向右滑动 1 个元素，则它将变为 [i+1, j+1)（左闭，右开）。注意，滑动当然也可以是一侧滑动，即一边动，另一边保持不动，即窗口向右“延伸”。<br>                                            <img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%A4%BA%E6%84%8F.png" alt><br>回到我们的问题，我们使用 HashSet 将字符存储在当前窗口 [i, j)（最初 j = i）中。<br>1、我们向右滑动索引 j，当s[j]不在该窗口中时，我们就将他加入HashSet中(相当于窗口向右延伸)，然后我们继续向右滑动索引j，直到s[j]已经在该窗口中，这个过程中，我们可以得到当前无重复字符的长度；<br>2、二是当s[j]已经在该窗口中时，我们此时需要向右滑动索引 i（即去掉窗口左边的第一个元素，缩小了窗口），然后继续判断s[j]是否存在当前窗口中，重复滑动索引i，直到s[j]不存在当前窗口。原理就是当s[j]存在当前窗口时，那么和这一部分子串相关的最长无重复子串长度值就已经唯一确定了。<br>                                 <img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/%E6%BB%91%E5%8A%A8%E7%B4%A2%E5%BC%952.png" alt="步骤2示意图"><br>3、当我们对所有的索引 i 进行1、2两步操作，我们就可以得到答案。<br><strong>code：</strong></p><pre><code>class Solution {public:    int lengthOfLongestSubstring(string s) {        set&lt;char&gt; set1;        int n = s.length();        int i,j,ans;        i = j = ans = 0;        while(i &lt; n &amp;&amp; j &lt; n)        {            if(set1.find(s[j]) == set1.end()) //集合中不包含该字符串，则插入            {                set1.insert(s[j++]);                ans = max(ans,j-i);            }            else            {                set1.erase(s[i++]);   //集合中包含该元素，则窗口向右滑动            }        }        return ans;    }};</code></pre><p><strong>时间复杂度：</strong><br> 时间复杂度：O(2n) = O(n)，在最糟糕的情况下，每个字符将被 i 和 j 访问两次。空间复杂度：O(min(m, n))，与之前的方法相同。滑动窗口法需要 O(k)的空间，其中 k 表示 Set 的大小。而Set的大小取决于字符串 n 的大小以及字符集/字母 m 的大小。</p><p><strong>思路三(优化的滑动窗口)：</strong><br>    上述的方法最多需要执行 2n 个步骤。事实上，它可以被进一步优化为仅需要 n 个步骤。在上面的步骤2中，我们提到了当出现s[j]存在于集合中时，我们就已经唯一确定了和这一部分子串相关的最长无重复子串长度值。我们上面的做法是通过移动索引 i , 直到窗口不含重复字符。而这一步骤我们是可以优化的。我们是否可以直接移动到那个不含重复字符的位置呢？<br>    方法就是将字符串采用字符到索引的映射，比如用HashMap存储而不是HashSet，这样，我们不断的将给定字符串加入到HashMap时，当遇到要加入的字符存在于HashMap时，我们能够直接定位到重复字符在HashMap的具体位置，而不需要像方法二中一样不断的移动索引 i 来确定位置，这样就实现了直接“跳过窗口”，提高了效率。<br>    优化思路总结：采用HashMap存储，如果 s[j] 在HashMap的 [i, j)范围内存在相同字符(假设重复字符下标在HashMap为k，i &lt;= k &lt;j )，我们不需要逐渐增加 i。 我们可以直接跳过 [i，k ] 范围内的所有元素，并将 i 变为 k+1,即此时的窗口为 [k+1,j)。<br>                                                   <img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/%E4%BC%98%E5%8C%96%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="优化的滑动窗口示意图"><br><strong>code：</strong></p><pre><code>class Solution {public:    int lengthOfLongestSubstring(string s) {        unordered_map&lt;char,int&gt; Elem_LastPos;        int maxLen = 0,curLen = 0;    //curLen用于实时的记录无重复字符串长度        for(int i = 0;i &lt; s.length();i++)        {            //第二个判断是为了防止连续不同字母但重复字符的出现（eg：abba），i-Elem_LastPos[s[i]]一定满足&lt;=上一次的实时长度            if(Elem_LastPos.find(s[i]) != Elem_LastPos.end() &amp;&amp; i-Elem_LastPos[s[i]]&lt;=curLen)                curLen = i-Elem_LastPos[s[i]];            else                curLen += 1;            //不存在            Elem_LastPos[s[i]] = i;    //不存在，则加入到HashMap,存在，则跳过窗口[i,k)            maxLen = maxLen &gt; curLen ? maxLen:curLen;        }        return maxLen;    }};</code></pre><p><strong>时间复杂度：</strong><br>时间复杂度：O(n)，索引 i 将会迭代 n 次。<br>空间复杂度（HashMap）：O(min(m, n)），与之前的方法相同。</p><p><strong>优化思路二：</strong><br>上述的优化方法是采用了HashMap的方法存储，当字符集比较小的时候，我们也可以考虑使用字符集映射的方法，一般的字符集的ASCIII码为0-127，故我们只需一个int a[128]的整数数组来实现字符的映射关系，从而代替map。</p><p><strong>code：</strong></p><pre><code>class Solution {public:    int lengthOfLongestSubstring(string s) {        int n = s.length();        int ans = 0;        int index[128] = {0};        for(int i = 0,j = 0;j &lt; n;j++)        {            i = max(index[s[j]],i);    //判断是否存在（重复），不存在，则继续直接计算长度(j-i+1)。存在，则跳过窗口，即更新最新索引i            ans = max(ans,j-i+1);        //更新长度            index[s[j]] = j + 1;        //表示插入字符集映射表，包括更新重复字符的最新值，为了下一次更新索引i        }        return ans;    }};</code></pre><p><strong>时间复杂度：</strong><br>时间复杂度：O(n)，索引 j 将会迭代 n 次。空间复杂度（Table）：O(m)，m 是字符集的大小。</p>]]></content>
      
      
      <categories>
          
          <category> Programming Thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github搭建个人博客</title>
      <link href="/2019/03/08/hexo-github-da-jian-ge-ren-bo-ke/"/>
      <url>/2019/03/08/hexo-github-da-jian-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<p>前言：<br>    花了两天时间，总算是搭建了自己的个人博客。基本上跟着网上大神的教程做，大部分很顺利，但还是不可避免的遇到一些小的坑，因此花费了不少的时间，故在此也总结一下自己遇到的问题，若大家遇到相似的问题，可以快速的解决。搭建博客主要是下面三个方面，完成后就可以完美的发博客啦。</p><h3 id="步骤-教程直通车"><a href="#步骤-教程直通车" class="headerlink" title="步骤+教程直通车:"></a><strong>步骤+教程直通车</strong>:</h3><h4 id="1、hexo-github-搭建个人博客"><a href="#1、hexo-github-搭建个人博客" class="headerlink" title="1、hexo + github 搭建个人博客:"></a>1、hexo + github 搭建个人博客:</h4><pre><code>[网址传送门：](https://mp.weixin.qq.com/s?__biz=MzI5NDY1MjQzNA==&amp;mid=2247488956&amp;idx=3&amp;sn=a0c52c1a270269925fc6ea9e84596e10&amp;chksm=ec5ecac1db2943d75368ef598fd22eda6497dbc35e5b8941335d2fc9e44de516bcc470f8e4a2&amp;mpshare=1&amp;scene=1&amp;srcid=0302seoWmMigQ065XCb3qvxP&amp;key=0c5bd8d37f17829348d3918abd80122f9caed41ef7b4beefc679edddb6b35997f0f0ad370cf89dbe6c92ab782f69d7bacc8a7a59f3d7a19fb1069951797c63f67131fb05a0f8ab28ae68db51b144f374&amp;ascene=1&amp;uin=MjY0NTYwMzU0Mw%3D%3D&amp;devicetype=Windows+10&amp;version=62060728&amp;lang=zh_CN&amp;pass_ticket=1UsAPqwJzqsYyPrWZrAjE7b15egEPEQyl1ynzAbdrWvGDxenn7xA694UKAIrWc0V)</code></pre><h4 id="2、选择主题："><a href="#2、选择主题：" class="headerlink" title="2、选择主题："></a>2、选择主题：</h4><p><a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/" target="_blank" rel="noopener">网址传送门：</a></p><h4 id="3、搭建图床："><a href="#3、搭建图床：" class="headerlink" title="3、搭建图床："></a>3、搭建图床：</h4><p><a href="https://www.cnblogs.com/asheng2016/p/9572128.html" target="_blank" rel="noopener">网址传送门：</a><br>    个人就是按照上面的网址教程一步步的安装完成的。现在来说一下我遇到的一些问题…</p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p>1、选择主题并配置后，页面没有任何变化，依旧是原始画面。<br>        是因为从网上下载解压后的主题文件夹名字与_config.yml文件里面的配置不同，必须改为一致的。<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/blogcfg.png" alt><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/docname.png" alt><br>2、按照主题帖创建主题后，出现了博客页面空白的现象。<br>        这个是因为按照教程修改配置时，在改动项冒号后直接写内容，导致页面不显示。_config.yml 文件里所有配置项的内容都需要在其冒号后空一格再写内容。<br>3、想换掉主题 中的照片、logo时，改成一样的名字没有成功。<br>        因为图片的格式与之前的不同，可能你的是a.png，原主题的是a.jpg的，所以和其配置选项中的名字不同，导致换图片失败。<br>4、利用hexo + github搭建好博客后，在git bash 里输入hexo server 启动本地预览（<a href="http://localhost:4000/）发现页面找不到，404错误等。" target="_blank" rel="noopener">http://localhost:4000/）发现页面找不到，404错误等。</a><br>        很有可能4000这个端口被占用，此时可以输入命令 (hexo server -p 5000) 来换一个端口就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyFirstBlog</title>
      <link href="/2019/03/07/myfirstblog/"/>
      <url>/2019/03/07/myfirstblog/</url>
      
        <content type="html"><![CDATA[<pre><code>    在hexo+github上的第一个博客，看看效果。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
