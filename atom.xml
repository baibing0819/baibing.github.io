<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>IceBai</title>
  
  <subtitle>WhiteIce</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://baibing0819.github.io/"/>
  <updated>2019-05-28T12:54:23.776Z</updated>
  <id>http://baibing0819.github.io/</id>
  
  <author>
    <name>Ice White</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Knime之多元线性回归及模型优化</title>
    <link href="http://baibing0819.github.io/2019/05/28/knime-zhi-duo-yuan-xian-xing-hui-gui-ji-mo-xing-you-hua/"/>
    <id>http://baibing0819.github.io/2019/05/28/knime-zhi-duo-yuan-xian-xing-hui-gui-ji-mo-xing-you-hua/</id>
    <published>2019-05-28T03:20:00.000Z</published>
    <updated>2019-05-28T12:54:23.776Z</updated>
    
    <content type="html"><![CDATA[<p>本文基于房价预测问题来在Knime上实现多元线性回归，并在此基础上讨论如何优化模型。文末提供数据获取地址及knime工作流。</p><p>多元线性回归预测函数  （即含有更多的特征，多特征问题）：  </p><p>$ h_\theta（x） = \theta_0 + \theta_1 * x_1 + \theta_2 * x_2 + … + \theta_n * x_n $</p><p>knime工作流：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/MultiLinearRegreession/1.jpg" alt></p><p>可以看出来，多元线性回归和线性回归似乎是一样的，它在数据上有更多的特征信息，我们需要建立起这些特征与目标的关系，这个图实现的具体细节这里就不再赘述了，有疑问的可以看我的前一篇Knime之线性回归的文章，接下来我们主要讲一下模型优化的一些方法。</p><p>原始数据图：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/MultiLinearRegreession/5.jpg" alt><br>模型优化：<br>多元线性回归问题它的特点是特征多，而并不是所有的特征都是与我们的目标预测值都有很大的关联，可能有的特征对目标预测值的影响几乎微乎其微，而计算机在训练模型时，为了将所有的特征都考虑进去，可能会出现过拟合的问题，即在已有训练集上完美表现，但是在测试集、未知数据上表现很差，所以我们可以通过减少特征、选取合适的特征来训练模型。<br>1、数据可视化<br>在训练模型之前，我们可以用一些数据可视化的节点来分析我们的原始数据，看是否能够得到一些特征与目标之间的关联程度，这样在前期我们就可能做到去掉那些毫无关联的特征。这些节点如下图（具体获取细节参见前一章的线性回归内容）：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/MultiLinearRegreession/3.jpg" alt><br>Statistics节点：<br>他能够帮我们统计每一个特征的平局值、最大、最小，数据分布位置等信息。<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/MultiLinearRegreession/6.jpg" alt><br>Scatter Matrix节点：<br>他帮助我们得到数据之间的关系，如下图我们选中节点来看他的视图(右键 view ..),最下方让我们来选择想要看到的变量之间关系，左边是去掉的变量，右边是选择的变量，这里我们选择了卧室和房屋价格之间的关系，由红色圆圈部分我们可与看出随着卧室数量的增加，房屋价格也在逐渐增加，但增加到一定程度时，卧室数量继续增加，此时房屋反而下降。<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/MultiLinearRegreession/7.jpg" alt><br>Scatter Plot节点：<br>他具有和Scatter Martrix相似的功能，不过他只是显示两个变量之间的关系，操作如下图：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/MultiLinearRegreession/8.jpg" alt><br>Histogram(interactive)节点：<br>绘制变量关系直方图，操作如下图，可以看出bathroom和房屋价格之间的关系：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/MultiLinearRegreession/9.jpg" alt></p><p>Linear Correlation：<br>该节点能够显示所有特征两两之间的关联程度(根据颜色的深浅)，如图，我们能够清晰的看出房屋价格与哪些变量之间有密切的关联。<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/MultiLinearRegreession/10.jpg" alt></p><p>2、整合节点<br>上面我们解释了很多的数据可视化的节点，将他们都放到同一界面显得有点乱且占空间，这时我们可以将他们整合为一个元节点，使界面更加整洁。操作是按住ctrl键选择要整合的所有节点，然后鼠标右键任意其中一个节点，选择collapse into MetaNode，然后给他名字即可，效果图如下。<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/MultiLinearRegreession/11.jpg" alt></p><p>3、选择特征<br>Column Filter：<br>我们用该节点来选择特征作为输入，即可以在训练模型之前去掉不需要的特征，配置如图，这里我只去掉了id这一特征。<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/MultiLinearRegreession/12.jpg" alt></p><p>Foward Feature Selection：<br>该节点也是一个元节点，双击可查看其内部节点构造，如图<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/MultiLinearRegreession/4.jpg" alt></p><p>节点功能：特征选择：正向选择(如下表述)</p><pre><code> while((p值大于阈值) &amp;&amp; （特征数量达到上线）):      1、选择一个最相关的特征输入模型（每个特征分别输入模型，选择p值最小的特征）      2、保留上一个特征，从剩余的特征中再选择一个输入模型</code></pre><p>-我们看一下 loop start节点配置，如图，左边static columns表示不变的特征，即我们肯定选择的特征，这是我们通过之前的数据分析得到的必定相关的特征。右边则是可变特征，需要元节点自行根据上述程序选择。下方则是设置特征数量的阈值，我们最多想要多少个特征。<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/MultiLinearRegreession/13.jpg" alt></p><p>-partionlng节点和之前一样的配置即可，接下来的三个黄框选中的节点是要求我们自己来替换的，分别是训练模型的学习器，模型预测器以及scorer，且配置与线性回归类似。需要注意的是numerical scorer的配置，如下图，需要选中复选框，因为我们的下一个节点loop end的输入需要为flow variable，配置好后我们右键scorer节点，选择show flow variables ports，然后将其与loop end连接即可。<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/MultiLinearRegreession/14.jpg" alt></p><p>-接着我们需要配置loop end节点，如图，表示我们期望节点最后选择的特征能给出的效果，这里我们选择平方差，且候选最小值（平方差越小意味着我们的模型效果越好）<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/MultiLinearRegreession/15.jpg" alt></p><p>-最后我们全部运行该元节点，需要等一段时间，最后运行结束后，我们双击最后一个节点Feature selection Filter，可以看到运行的结果，如下图。经比较，我们选择了相对最好的一组特征（平方差相对最小且特征量多一点）<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/MultiLinearRegreession/16.jpg" alt></p><p>特征归一化：<br>特征归一化能够更高效的找到最合适的模型，从图像上看经过归一化后，特征图更加的圆滑而非原始的窄长型，具体的细节大家可以看下吴恩达的机器学习课程，这里就不在赘述了，直接附归一化公式   （z-score公式） ：$ x_i = (x_i - \mu)/ \sigma $ ,其中 $\sigma$ 是标准差，还有另外一个公式（最大最小公式）即：$ x_i = (x_i - \mu)/ s $ ,其中s = max -min 。</p><p>我们使用Normalizer以及Normalizer(Apply)，前者我们用于归一化训练集并保存归一化各个特征时的参数，后者则利用前者的参数对测试集进行归一化，(测试集相当于未知数据，我们不能直接将他归一化，即使目前他是已知的，但依旧要假设为未知，这也是划分数据的意义)。配置如下图：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/MultiLinearRegreession/18.jpg" alt></p><p>最后全部运行，得到结果如图，经过我们的优化，我们得到了不错的结果。当然，我们需要在优化上多做训练、多分析原始数据，本文只是介绍了方法，具体的应用还需多多实践。<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/MultiLinearRegreession/17.jpg" alt></p><p>附本文实例所需数据还有工作流文件：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文基于房价预测问题来在Knime上实现多元线性回归，并在此基础上讨论如何优化模型。文末提供数据获取地址及knime工作流。&lt;/p&gt;
&lt;p&gt;多元线性回归预测函数  （即含有更多的特征，多特征问题）：  &lt;/p&gt;
&lt;p&gt;$ h_\theta（x） = \theta_0 + \
      
    
    </summary>
    
      <category term="数据挖掘" scheme="http://baibing0819.github.io/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="Knime" scheme="http://baibing0819.github.io/tags/Knime/"/>
    
  </entry>
  
  <entry>
    <title>Knime之简单线性回归</title>
    <link href="http://baibing0819.github.io/2019/05/24/knime-zhi-xian-xing-hui-gui/"/>
    <id>http://baibing0819.github.io/2019/05/24/knime-zhi-xian-xing-hui-gui/</id>
    <published>2019-05-24T03:20:00.000Z</published>
    <updated>2019-05-24T08:33:44.763Z</updated>
    
    <content type="html"><![CDATA[<p>前言：<br>本文介绍如何利用数据挖掘工具knime来建立一个简单的机器学习工作流程–线性回归，本文是基于“工作年龄与薪酬的关系”问题进行建立knime工作流，从而建立该问题的预测模型。该线性回归工作流和所需的数据文件都已放在github，有需要的自行下载。<br>Github地址：<a href="https://github.com/baibing0819/MachineLearning/tree/master/Knime/LinearRegression" target="_blank" rel="noopener">https://github.com/baibing0819/MachineLearning/tree/master/Knime/LinearRegression</a></p><p>线性回归简单说明：<br>利用目前已有数据(csv格式)，将其分为训练集和测试集，其中训练集用于训练模型，测试集用于测试模型的效果。最终让模型实现根据当前工作年龄来预测出薪酬。<br>预测函数： $ y = \theta_0 + \theta_1*x$                          (也就是普通的直线方程)</p><p>knime工作流总图：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/linearRegression/15.jpg" alt></p><p>工作流建立步骤：<br>一、创建一个 CSV Reader（用于放我们的输入数据）：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/linearRegression/1.jpg" alt></p><p>2、双击节点打开配置界面，导入我们的输入数据，因为我们的数据只有列id是有用的，没有行id，所以下面只勾选has column header<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/linearRegression/99.jpg" alt></p><p>  右键节点，选中file table可以查看我们的数据：<br>  <img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/linearRegression/2.jpg" alt><br>  配置完成后，点击运行节点，可以看到节点下面的指示灯由黄色变成绿色，说明建立成功。<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/linearRegression/3.jpg" alt></p><p>二、scatter plot节点查看数据散点图<br>我们可以创建一个scatter plot节点来查看我们的数据散点图，如图，我们选择该节点并创建，然后将reader的输出端口连接到scatter plot的输入（鼠标保持左击画线即可），然后运行该节点，显示绿灯表示成功。此时，鼠标右键scatter plot节点选择view scatter plot，就可以查看图像了。<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/linearRegression/6.jpg" alt><br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/linearRegression/4.jpg" alt></p><p><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/linearRegression/100.jpg" alt></p><p>三、partitionlng 节点划分数据<br>获取输入数据后，我们需要一个partitionlng节点将数据划分为训练集和测试集。如下图，选择该节点并与reader的输出连接，双击该节点进入配置选项，选择如下配置，Relative表示第一部分数据占总体的比例，这里选择70%，即按7:3的比例划分为训练集和测试集，下面的三个选项为划分数据的方式，我们选择随机选取70%。然后运行，无异常。<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/linearRegression/8.jpg" alt></p><p>四、Linear Regression Learner节点训练模型<br>创建Linear Regression Learner节点进行数据的训练，将partitionlng第一个输出连接到linear的输入，两个输出端口的定义可以在node descriptio中看到，如下图，可以看出第一个输出口是训练集数据，即我们在partitionlng设置的first partition，运行，无异常。<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/linearRegression/9.jpg" alt></p><p>五、RegressionPredictor节点得到训练模型<br>创建RegressionPredictor节点得到训练模型，并用测试集进行测试我们的模型效果，将Linear Regression Learner第一个输出(输出模型)连到Predictor的第一个输入，<br>partitionlng的第二个输出（测试集）连接到Predictor的第二个输入(进行测试)。点击运行无异常。右键该节点选择Pridicted data可以查看到数据，可以对比真实数据和我们预测的数据差别是否很大。<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/linearRegression/10.jpg" alt></p><p>效果对比：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/linearRegression/14.jpg" alt></p><p>六、LinePlot、Numeric Scorer节点<br>预测之后，我们需要查看该模型的效果及预测函数是什么样子的，其中LinePlot用于对比我们的数据真实曲线和通过模型预测的数据曲线，创建直接连接即可。然后右击该节点选择 view line plot即可查看效果，如下图。Numeric Scorer用于得出显示我们模型性能的一些参数值，如图。分别是$R^2$、方差、绝对误差、标准差、平均有符号差。</p><p><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/linearRegression/12.jpg" alt></p><p><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/linearRegression/13.jpg" alt></p><p><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/knime/linearRegression/15.jpg" alt></p><p>至此，一个简单的线性回归模型就成功完成了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前言：&lt;br&gt;本文介绍如何利用数据挖掘工具knime来建立一个简单的机器学习工作流程–线性回归，本文是基于“工作年龄与薪酬的关系”问题进行建立knime工作流，从而建立该问题的预测模型。该线性回归工作流和所需的数据文件都已放在github，有需要的自行下载。&lt;br&gt;Gith
      
    
    </summary>
    
      <category term="数据挖掘" scheme="http://baibing0819.github.io/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="Knime" scheme="http://baibing0819.github.io/tags/Knime/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu18.04安装Tensorflow-gpu</title>
    <link href="http://baibing0819.github.io/2019/05/22/ubuntu18.04-an-zhuang-tensorflow-gpu/"/>
    <id>http://baibing0819.github.io/2019/05/22/ubuntu18.04-an-zhuang-tensorflow-gpu/</id>
    <published>2019-05-22T03:20:00.000Z</published>
    <updated>2019-05-23T02:11:10.658Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言：</strong><br>学习深度学习，安装框架，本文介绍的是安装Tensorflow-gpu版本，如果你的电脑有NVIDA显卡，那么就可以安装，文章主要介绍如何安装Ubuntu18.04 + Tensorflow-gpu + cuda8.0 + cuDNN6.0。</p><p><strong>一些名词：</strong><br><strong>CUDA</strong>(Compute Unified Device Architecture)，是显卡厂商NVIDIA推出的运算平台。CUDA™是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。<br><strong>NVIDIA cuDNN</strong>是用于深度神经网络的GPU加速库。它强调性能、易用性和低内存开销。NVIDIA cuDNN可以集成到更高级别的机器学习框架中，如加州大学伯克利分校的流行caffe软件。简单的，插入式设计可以让开发人员专注于设计和实现神经网络模型，而不是调整性能，同时还可以在GPU上实现高性能现代并行计算。</p><p><strong>安装过程：</strong><br><strong>一、打开软件更新-&gt;附加驱动，选择nvidia最新驱动，然后应用更改。</strong><br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/deeplearning/tensorflow-gpu/8.jpg" alt><br>验证驱动是否安装成功：在应用搜索栏输入NVIDA，找到NVIDIA X Sever Settings并打开<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/deeplearning/tensorflow-gpu/10.png" alt><br>安装成功！</p><p><strong>二、安装Tensorflow依赖的编译工具bazel</strong><br>1、安装bazel前，需先安装JDK8：<br>sudo apt-get install software-properties-common</p><p>sudo add-apt-repository ppa:webupd8team/java</p><p>sudo apt-get update</p><p>sudo apt-get install openjdk-8-jdk</p><p>安装完成后 验证java版本：java -version<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/deeplearning/tensorflow-gpu/1.jpg" alt><br>2、安装bazel：<br>echo “deb [arch=amd64] <a href="http://storage.googleapis.com/bazel-apt" target="_blank" rel="noopener">http://storage.googleapis.com/bazel-apt</a> stable jdk1.8” | sudo tee /etc/apt/sources.list.d/bazel.list</p><p>sudo apt install curl</p><p>sudo apt-get update </p><p>sudo apt-get install bazel</p><p>sudo apt-get upgrade bazel </p><p><strong>三、安装cuda 8.0</strong><br>1、cuda 8.0 下载地址：<a href="https://developer.nvidia.com/cuda-80-ga2-download-archive" target="_blank" rel="noopener">https://developer.nvidia.com/cuda-80-ga2-download-archive</a><br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/deeplearning/tensorflow-gpu/2.jpg" alt><br>2、下载完成后定位到下载目录，输入命令运行该文件<br>sudo sh cuda_8.0.27_linux.run –override</p><p>注：–override是我在遇到gcc编译器版本过高时的解决办法，下面还是会需要对gcc降级，这里先用此方法处理，此时若遇到错误(在提示信息给出的log文件里可以查看到)：Can’t locate InstallUtils.pm in @INC，参考该博客解决方案：<a href="https://www.brilliantcode.net/1211/ubuntu-install-cuda-error-cant-locate-installutils-pm-in-inc/" target="_blank" rel="noopener">https://www.brilliantcode.net/1211/ubuntu-install-cuda-error-cant-locate-installutils-pm-in-inc/</a><br>关键部分：<br>mkdir cuda-8<br>sudo sh cuda_8.0.61_375.26_linux.run –noexec –target cuda-8<br>cp cuda-8/InstallUtils.pm /usr/share/perl5</p><p>3、安装结束后添加环境变量，输入 vim ~/.bashrc<br>export PATH=/usr/local/cuda-8.0/bin:$PATH</p><p>export LD_LIBRARY_PATH=/usr/local/cuda-8.0/lib64:$LD_LIBRARY_PATH</p><p>4、nvcc -V</p><p>如果没有nvcc则安装 sudo apt install nvidia-cuda-toolkit</p><p>nvcc -V</p><p>nvidia-smi<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/deeplearning/tensorflow-gpu/3.jpg" alt></p><p>5、验证cuda8是否安装成功：<br>    进入NVIDIA_CUDA-8.0_Samples目录，执行：make，这里应该会报错，因为cuda8.0不支持gcc 5.0以上的编译器，因此需要降级，把编译器版本降到4.8，降级方法参考博客：<a href="https://blog.csdn.net/qq_31175231/article/details/77774971" target="_blank" rel="noopener">https://blog.csdn.net/qq_31175231/article/details/77774971</a></p><p>关键命令记录(g++只需替换gcc即可)：<br>sudo apt-get install gcc-4.8<br>sudo update-alternatives –install /usr/bin/gcc gcc /usr/bin/gcc-4.8 100<br>sudo update-alternatives –config gcc   （用于验证）<br>gcc –version       （用于验证）</p><p>6、CUDA8.0安装成功测试，<br>进入NVIDIA_CUDA-8.0_Samples目录，执行： sudo make （需等待一段时间）</p><p>结束后进入1_Utilities目录，执行：./deviceQuery/deviceQuery ，结果如下：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/deeplearning/tensorflow-gpu/4.png" alt><br>执行： nvcc -V，结果如下：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/deeplearning/tensorflow-gpu/5.jpg" alt></p><p>四、安装cuDNN6.0<br>下载地址6.0： <a href="https://developer.nvidia.com/rdp/cudnn-archive" target="_blank" rel="noopener">https://developer.nvidia.com/rdp/cudnn-archive</a></p><p>打开终端，定位到下载的文件所在文件夹，依次输入命令：</p><p>tar -xvzf cudnn-8.0-linux-x64-v6.0.tgz<br>sudo cp -P cuda/include/cudnn.h /usr/local/cuda-8.0/include<br>sudo cp -P cuda/lib64/libcudnn* /usr/local/cuda-8.0/lib64</p><p>配置环境变量；<br>sudo vim ~/.bashrc</p><p>添加：<br>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda/lib64:/usr/local/cuda/extras/CUPTI/lib64”<br>export CUDA_HOME=/usr/local/cuda</p><p>export PATH=””$CUDA_HOME/bin:$PATH”</p><p>再执行：source ~/.bashrc</p><p>配置完成！</p><p>五、Tensorflow（GPU）安装 ,输入命令</p><p>pip install <a href="https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow_gpu-1.2.0-cp27-none-linux_x86_64.whl" target="_blank" rel="noopener">https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow_gpu-1.2.0-cp27-none-linux_x86_64.whl</a></p><p>注意：若出现错误：tensorflow-0.5.0-cp27-none-linux_x86_64.whl is not a supported wheel on this platform.<br>解决办法，输入以下命令：<br>wget <a href="https://bootstrap.pypa.io/get-pip.py" target="_blank" rel="noopener">https://bootstrap.pypa.io/get-pip.py</a></p><p>sudo python2.7 get-pip.py                                                                                                </p><p>sudo python2.7 -m pip install <a href="https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.5.0-cp27-none-linux_x86_64.whl" target="_blank" rel="noopener">https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.5.0-cp27-none-linux_x86_64.whl</a> –default-timeout=1000</p><p>测试：<br>进入python环境，输入：python2.7<br>输入以下代码：<br>import tensorflow as tf</p><p>a=tf.constant([1.0,2.0,3.0],shape=[3],name=’a’)</p><p>b=tf.constant([1.0,2.0,3.0],shape=[3],name=’b’)</p><p>c=a+b</p><p>sess=tf.Session(config=tf.ConfigProto(log_device_placement=True))</p><p>print sess.run(c)<br>效果图如下：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/deeplearning/tensorflow-gpu/6.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;br&gt;学习深度学习，安装框架，本文介绍的是安装Tensorflow-gpu版本，如果你的电脑有NVIDA显卡，那么就可以安装，文章主要介绍如何安装Ubuntu18.04 + Tensorflow-gpu + cuda8.0 + cu
      
    
    </summary>
    
      <category term="DeepLearning" scheme="http://baibing0819.github.io/categories/DeepLearning/"/>
    
    
      <category term="DeepLearning" scheme="http://baibing0819.github.io/tags/DeepLearning/"/>
    
      <category term="tool" scheme="http://baibing0819.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>pycharm的简单配置</title>
    <link href="http://baibing0819.github.io/2019/05/13/pycharm/"/>
    <id>http://baibing0819.github.io/2019/05/13/pycharm/</id>
    <published>2019-05-13T12:20:00.000Z</published>
    <updated>2019-05-13T12:08:53.978Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Pycharm下初次使用的一些配置选项：</strong><br>今天个人在ubuntu下使用pycharm创建自己的第一个python工作环境，遇到一些小的问题，在这里记录下来<br>1、选择编译器：个人安装的是anaconda3+pycharm，所以在这里选择了conda解释器来作为编译器，打开pycharm选择file-&gt;setting,接下来具体配置见图：<br>①点击按钮添加：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/python/interpreter.jpg" alt><br>②选择编译器：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/python/interpreter1.jpg" alt></p><p>2、配置程序模板，<br>我们可以为自己经常创建的文件设置模板，比如为.py文件设置抬头，程序功能、编写日期、作者等信息，这样我们之后创建就不需要做重复的工作了，具体步骤如下：同样的，选择file-&gt;setting，然后作如下配置。<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/python/code_template.jpg" alt><br>效果图如下：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/python/templateview.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Pycharm下初次使用的一些配置选项：&lt;/strong&gt;&lt;br&gt;今天个人在ubuntu下使用pycharm创建自己的第一个python工作环境，遇到一些小的问题，在这里记录下来&lt;br&gt;1、选择编译器：个人安装的是anaconda3+pycharm，所以在这
      
    
    </summary>
    
      <category term="Python" scheme="http://baibing0819.github.io/categories/Python/"/>
    
    
      <category term="pycharm" scheme="http://baibing0819.github.io/tags/pycharm/"/>
    
  </entry>
  
  <entry>
    <title>linnux应用图标及快速启动</title>
    <link href="http://baibing0819.github.io/2019/05/09/desktop/"/>
    <id>http://baibing0819.github.io/2019/05/09/desktop/</id>
    <published>2019-05-09T03:20:00.000Z</published>
    <updated>2019-05-09T08:58:28.387Z</updated>
    
    <content type="html"><![CDATA[<p><strong>ubuntu下为应用设置启动图标</strong><br>在ubuntu系统下，通常会有一些应用程序通过终端来打开，这时候我们希望在图形化桌面创建一个他的快捷方式，从而方便的打开它，这里，来记录一下创建过程。 这里我以为微信网页版应用建立桌面图标为例，其他应用步骤相同.<br>1、首先打开终端，进入目录cd /usr/share/applications<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/linux/indir.jpg" alt><br>2、sudo vim wechat.desktop（注：名字自己取，后缀不要改）<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/linux/desktop.jpg" alt><br>3、打开之后添加以下内容：<br>[Desktop Entry]<br>Name=WeChat<br>Comment=WeChat Client<br>Exec=/存放应用程序的绝对路径/<br>Icon=/存放应用程序图标的绝对路径/<br>Terminal=false<br>Type=Application<br>Categories=Application;<br>Encoding=UTF-8<br>StartupNotify=true<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/linux/desktopcode.jpg" alt></p><p>注意：应用程序和为他设置的图片放在同一文件夹下。完成后保存退出，就能够在应用搜索栏里查找的你设置<br>的应用启动图标了。<br>下面是效果图：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/linux/xiaoguotu.png" alt></p><p><strong>二、为应用设置环境变量—终端快捷启动</strong><br>有时我们也不想设置过多的应用图标，希望能够从终端快速输入软件名字直接启动，这时，我们就可以为其设置环境变量。环境变量的作用就是让用户能够无需cd到可执行应用文件夹下在任意当前目录下可以直接输入应用名字打开。过程如下：<br>1、用vim打开环境变量配置文件： vim ~/.bashrc<br>2、追加环境变量路径(将你要设置的应用的绝对路径加入，见下图内容中的最后一行)：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/linux/path.jpg" alt><br><strong>Tips：</strong><br>在我们能够从终端输入应用名字快速启动，有时候我们发现该应用会占用我们的当前终端，用户无法在做其他操作，直到该应用退出或是重新打开一个终端。这时我们可以使用 &amp; 让应用后台运行，解决无法控制终端问题。例如打开atom，输入 atom &amp;即可。更进一步，如果不限每次都这样输入，我们同样可以写进环境变量文件，即用alias设置别名：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/linux/alias.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;ubuntu下为应用设置启动图标&lt;/strong&gt;&lt;br&gt;在ubuntu系统下，通常会有一些应用程序通过终端来打开，这时候我们希望在图形化桌面创建一个他的快捷方式，从而方便的打开它，这里，来记录一下创建过程。 这里我以为微信网页版应用建立桌面图标为例，其他应
      
    
    </summary>
    
      <category term="Linux" scheme="http://baibing0819.github.io/categories/Linux/"/>
    
    
      <category term="linux tips" scheme="http://baibing0819.github.io/tags/linux-tips/"/>
    
  </entry>
  
  <entry>
    <title>sciencenet1</title>
    <link href="http://baibing0819.github.io/2019/04/24/sciencenet1/"/>
    <id>http://baibing0819.github.io/2019/04/24/sciencenet1/</id>
    <published>2019-04-24T03:20:00.000Z</published>
    <updated>2019-05-09T08:26:55.134Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Clash for linux:</strong><br>1、clash-linux获取地址(选取amd版本即可)： <a href="https://github.com/Dreamacro/clash/releases" target="_blank" rel="noopener">https://github.com/Dreamacro/clash/releases</a><br>2、教程网址：<a href="https://withdewhua.space/2019/01/22/use-clash-linux-in-deepin/" target="_blank" rel="noopener">https://withdewhua.space/2019/01/22/use-clash-linux-in-deepin/</a><br>3、编辑~/.config/clash下的 config.yml文件<br>4、因为没有gui界面，网页管理clash，重新启动 clash-linux 以加载配置文件，可通过 <a href="http://clash.razord.top/" target="_blank" rel="noopener">http://clash.razord.top/</a> 或者 <a href="http://yacd.haishan.me/#/" target="_blank" rel="noopener">http://yacd.haishan.me/#/</a> 进行策略组节点的切换，连接的 ip 和端口根据自己的 config.yml 中的external-controller填写；<br>5、可配合浏览器插件使用，也可以使用系统代理（推荐），系统代理可在控制中心-&gt;网络-&gt;系统代理-&gt;手动处填写（根据自己配置文件里的端口填写）。（例如 个人配置文件ip为127.0.0.1   socks端口为8888 http端口为8889，则在对应位置填写即可）</p><p>Tips：设置启动器图标及自启动 自己找一张图片当作 clash-linux 的图标，可存放在 clash-linux 同一文件夹下； 打开终端，输入sudo nano /usr/share/applications/clash.desktop，然后输入以下内容：</p><p>#以下内容自己根据实际情况编写<br>[Desktop Entry]<br>Name=Wechat<br>Version=0.10.2<br>Comment=A rule-based tunnel in Go<br>Exec=Clash full/path/to/clash-linux<br>Icon=/full/path/to/clash-logo.png Terminal=false<br>Type=Application<br>Categories=Network<br>注意：图片以微信应用为例<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/linux/desktopcode.jpg" alt><br>第二步做好之后启动器里可以找到 clash 了，右键点击后选中开机自动启动。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Clash for linux:&lt;/strong&gt;&lt;br&gt;1、clash-linux获取地址(选取amd版本即可)： &lt;a href=&quot;https://github.com/Dreamacro/clash/releases&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
      <category term="Personal Note" scheme="http://baibing0819.github.io/categories/Personal-Note/"/>
    
    
      <category term="tool" scheme="http://baibing0819.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>sciencenet</title>
    <link href="http://baibing0819.github.io/2019/04/19/sciencenet/"/>
    <id>http://baibing0819.github.io/2019/04/19/sciencenet/</id>
    <published>2019-04-19T03:20:00.000Z</published>
    <updated>2019-04-19T13:26:21.155Z</updated>
    
    <content type="html"><![CDATA[<p>ssr客户端下载：<br><a href="https://github.com/shadowsocksrr/shadowsocksr-csharp/releases" target="_blank" rel="noopener">https://github.com/shadowsocksrr/shadowsocksr-csharp/releases</a><br>节点网站（通过ssr客户端选取）：<br><a href="https://free-ss.site/" target="_blank" rel="noopener">https://free-ss.site/</a></p><p>clushx for window下载:<br><a href="https://github.com/Fndroid/clash_for_windows_pkg" target="_blank" rel="noopener">https://github.com/Fndroid/clash_for_windows_pkg</a><br>节点配置文件：<br><a href="https://api.loxcloud.com/ss/orders/101707/clashSub?port=17069&amp;passwd=VngBvFnH" target="_blank" rel="noopener">https://api.loxcloud.com/ss/orders/101707/clashSub?port=17069&amp;passwd=VngBvFnH</a><br>配置教程：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/net/clash%20for%20win%E9%85%8D%E7%BD%AE.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ssr客户端下载：&lt;br&gt;&lt;a href=&quot;https://github.com/shadowsocksrr/shadowsocksr-csharp/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/sh
      
    
    </summary>
    
      <category term="Personal Note" scheme="http://baibing0819.github.io/categories/Personal-Note/"/>
    
    
      <category term="tool" scheme="http://baibing0819.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>linux中的vim操作</title>
    <link href="http://baibing0819.github.io/2019/03/10/linux-zhong-de-vim-cao-zuo/"/>
    <id>http://baibing0819.github.io/2019/03/10/linux-zhong-de-vim-cao-zuo/</id>
    <published>2019-03-10T03:20:00.000Z</published>
    <updated>2019-04-19T09:36:27.423Z</updated>
    
    <content type="html"><![CDATA[<p>基本命令：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/linux/vim_cmd.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基本命令：&lt;br&gt;&lt;img src=&quot;https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/linux/vim_cmd.png&quot; alt&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Linux" scheme="http://baibing0819.github.io/categories/Linux/"/>
    
    
      <category term="vim" scheme="http://baibing0819.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>无重复字符的最长子串</title>
    <link href="http://baibing0819.github.io/2019/03/10/wu-chong-fu-zi-fu-de-zui-chang-zi-chuan/"/>
    <id>http://baibing0819.github.io/2019/03/10/wu-chong-fu-zi-fu-de-zui-chang-zi-chuan/</id>
    <published>2019-03-10T03:20:00.000Z</published>
    <updated>2019-03-15T06:24:24.281Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题描述：</strong><br>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p><p>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p><p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p><p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是子串的长度，”pwke” 是一个子序列，不是子串。</p><p><strong>思路一(暴力法)：</strong><br>    要找出无重复的最长子串，我们可以采用最直接的办法，先利用两个迭代给出所有可能的子串组合，然后我们建立一个判断字符串中每个字符是否唯一的函数就可以解决(字符串唯一，则返回true并求其长度。不唯一，则返回false)。其中allUnique()函数，使用集合形式去判断，利用集合元素必须唯一的特性，每当向集合中加入一个字符时，我们先判断其是否存在，若存在，则子串不唯一。遍历结束，就可以得出结论。<br><strong>code：</strong></p><pre><code>class Solution {public:    int lengthOfLongestSubstring(string s) {        int n = s.length();        int ans = 0;        for(int i = 0;i &lt; n;i++)            for(int j = i+1;j &lt;= n ;j++) //注意这里i、j的结束值，共n个字符，j可以取到n是用于allUnique()，这样才能取到所有组合                if(allUnique(s,i,j))                    ans = max(ans,j-i);        return ans;    }public:    bool allUnique(string s,int start,int end)    {        set&lt;char&gt; t;        for(int i =start; i &lt; end;i++)        {            if(t.find(s[i]) == t.end())                t.insert(s[i]);            else                return false;        }        return true;    }};</code></pre><p><strong>时间复杂度：</strong><br> 通过遍历给出所有可能的子串组合的时间复杂度为O(n^2)，而判断子串是否唯一的函数一次遍历需要O(J-I)，故总时间复杂度为O(n^3)；<br>空间复杂度的大小为集合所占用空间的大小，取决于字符串n和最长子串m的大小，为O(min(n,m))。</p><p><strong>思路二(滑动窗口)：</strong><br>    暴力法中，我们会对每一个子串的所有字符进行判读是否存在重复字符，但实际上并非必要。试想一下，假设字符串s的一个子串s[i]<del>s[j-1](下标为 i ~ j-1)已经判断为无重复子串，那么此时我们再判断和这个相关的子串s[i] ~ s[j]，我们只需要判断s[j]这一个字符是否已经存在于s[i]</del>s[j-1]即可，而不是再对这一个子串的所有字符进行判断。<br>    要检查一个字符是否已经在子字符串中，我们可以检查整个子字符串，这将产生一个复杂度为 O(n^2)的算法，但我们可以做得更好。通过使用HashSet 作为滑动窗口，我们可以用 O(1) 的时间来完成对字符是否在当前的子字符串中的检查。<strong>滑动窗口</strong>是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i, j)（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 [i, j)向右滑动 1 个元素，则它将变为 [i+1, j+1)（左闭，右开）。注意，滑动当然也可以是一侧滑动，即一边动，另一边保持不动，即窗口向右“延伸”。<br>                                            <img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%A4%BA%E6%84%8F.png" alt><br>回到我们的问题，我们使用 HashSet 将字符存储在当前窗口 [i, j)（最初 j = i）中。<br>1、我们向右滑动索引 j，当s[j]不在该窗口中时，我们就将他加入HashSet中(相当于窗口向右延伸)，然后我们继续向右滑动索引j，直到s[j]已经在该窗口中，这个过程中，我们可以得到当前无重复字符的长度；<br>2、二是当s[j]已经在该窗口中时，我们此时需要向右滑动索引 i（即去掉窗口左边的第一个元素，缩小了窗口），然后继续判断s[j]是否存在当前窗口中，重复滑动索引i，直到s[j]不存在当前窗口。原理就是当s[j]存在当前窗口时，那么和这一部分子串相关的最长无重复子串长度值就已经唯一确定了。<br>                                 <img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/%E6%BB%91%E5%8A%A8%E7%B4%A2%E5%BC%952.png" alt="步骤2示意图"><br>3、当我们对所有的索引 i 进行1、2两步操作，我们就可以得到答案。<br><strong>code：</strong></p><pre><code>class Solution {public:    int lengthOfLongestSubstring(string s) {        set&lt;char&gt; set1;        int n = s.length();        int i,j,ans;        i = j = ans = 0;        while(i &lt; n &amp;&amp; j &lt; n)        {            if(set1.find(s[j]) == set1.end()) //集合中不包含该字符串，则插入            {                set1.insert(s[j++]);                ans = max(ans,j-i);            }            else            {                set1.erase(s[i++]);   //集合中包含该元素，则窗口向右滑动            }        }        return ans;    }};</code></pre><p><strong>时间复杂度：</strong><br> 时间复杂度：O(2n) = O(n)，在最糟糕的情况下，每个字符将被 i 和 j 访问两次。空间复杂度：O(min(m, n))，与之前的方法相同。滑动窗口法需要 O(k)的空间，其中 k 表示 Set 的大小。而Set的大小取决于字符串 n 的大小以及字符集/字母 m 的大小。</p><p><strong>思路三(优化的滑动窗口)：</strong><br>    上述的方法最多需要执行 2n 个步骤。事实上，它可以被进一步优化为仅需要 n 个步骤。在上面的步骤2中，我们提到了当出现s[j]存在于集合中时，我们就已经唯一确定了和这一部分子串相关的最长无重复子串长度值。我们上面的做法是通过移动索引 i , 直到窗口不含重复字符。而这一步骤我们是可以优化的。我们是否可以直接移动到那个不含重复字符的位置呢？<br>    方法就是将字符串采用字符到索引的映射，比如用HashMap存储而不是HashSet，这样，我们不断的将给定字符串加入到HashMap时，当遇到要加入的字符存在于HashMap时，我们能够直接定位到重复字符在HashMap的具体位置，而不需要像方法二中一样不断的移动索引 i 来确定位置，这样就实现了直接“跳过窗口”，提高了效率。<br>    优化思路总结：采用HashMap存储，如果 s[j] 在HashMap的 [i, j)范围内存在相同字符(假设重复字符下标在HashMap为k，i &lt;= k &lt;j )，我们不需要逐渐增加 i。 我们可以直接跳过 [i，k ] 范围内的所有元素，并将 i 变为 k+1,即此时的窗口为 [k+1,j)。<br>                                                   <img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/%E4%BC%98%E5%8C%96%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="优化的滑动窗口示意图"><br><strong>code：</strong></p><pre><code>class Solution {public:    int lengthOfLongestSubstring(string s) {        unordered_map&lt;char,int&gt; Elem_LastPos;        int maxLen = 0,curLen = 0;    //curLen用于实时的记录无重复字符串长度        for(int i = 0;i &lt; s.length();i++)        {            //第二个判断是为了防止连续不同字母但重复字符的出现（eg：abba），i-Elem_LastPos[s[i]]一定满足&lt;=上一次的实时长度            if(Elem_LastPos.find(s[i]) != Elem_LastPos.end() &amp;&amp; i-Elem_LastPos[s[i]]&lt;=curLen)                curLen = i-Elem_LastPos[s[i]];            else                curLen += 1;            //不存在            Elem_LastPos[s[i]] = i;    //不存在，则加入到HashMap,存在，则跳过窗口[i,k)            maxLen = maxLen &gt; curLen ? maxLen:curLen;        }        return maxLen;    }};</code></pre><p><strong>时间复杂度：</strong><br>时间复杂度：O(n)，索引 i 将会迭代 n 次。<br>空间复杂度（HashMap）：O(min(m, n)），与之前的方法相同。</p><p><strong>优化思路二：</strong><br>上述的优化方法是采用了HashMap的方法存储，当字符集比较小的时候，我们也可以考虑使用字符集映射的方法，一般的字符集的ASCIII码为0-127，故我们只需一个int a[128]的整数数组来实现字符的映射关系，从而代替map。</p><p><strong>code：</strong></p><pre><code>class Solution {public:    int lengthOfLongestSubstring(string s) {        int n = s.length();        int ans = 0;        int index[128] = {0};        for(int i = 0,j = 0;j &lt; n;j++)        {            i = max(index[s[j]],i);    //判断是否存在（重复），不存在，则继续直接计算长度(j-i+1)。存在，则跳过窗口，即更新最新索引i            ans = max(ans,j-i+1);        //更新长度            index[s[j]] = j + 1;        //表示插入字符集映射表，包括更新重复字符的最新值，为了下一次更新索引i        }        return ans;    }};</code></pre><p><strong>时间复杂度：</strong><br>时间复杂度：O(n)，索引 j 将会迭代 n 次。空间复杂度（Table）：O(m)，m 是字符集的大小。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;问题描述：&lt;/strong&gt;&lt;br&gt;给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: “abcabcbb”&lt;br&gt;输出: 3&lt;br&gt;解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。&lt;br&gt;
      
    
    </summary>
    
      <category term="Programming Thinking" scheme="http://baibing0819.github.io/categories/Programming-Thinking/"/>
    
    
      <category term="leetcode" scheme="http://baibing0819.github.io/tags/leetcode/"/>
    
      <category term="字符串" scheme="http://baibing0819.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>两数之和</title>
    <link href="http://baibing0819.github.io/2019/03/10/liang-shu-zhi-he/"/>
    <id>http://baibing0819.github.io/2019/03/10/liang-shu-zhi-he/</id>
    <published>2019-03-10T03:20:00.000Z</published>
    <updated>2019-03-13T12:19:27.487Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题描述：</strong><br>        给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，返回的两个下标不能相同，即不能为相同的一个元素。<br>示例：<br>        给定 nums = [2, 7, 11, 15], target = 9<br>        因为 nums[0] + nums[1] = 2 + 7 = 9<br>        所以返回 [0, 1]</p><p><strong>思路一（暴力法）：</strong><br>        遍历每个元素 x，并查找是否存在一个值与 target - x 相等的目标元素。显然是需要两个迭代，使用C编写。<br><strong>code:</strong></p><pre><code>int* twoSum(int* nums, int numsSize, int target) {    static int a[2] = {0};    int i,j;    i = j = 0;    for(i = 0;i &lt; numsSize;i++)    {        for(j = i+1;j &lt; numsSize;j++)        {            if(nums[i] + nums[j] == target)            {                a[0] = i;                a[1] = j;                return a;            }        }    }    return 0;}</code></pre><p>复杂度：<br>       时间复杂度：O(n^2)；            空间复杂度：O(1)</p><p><strong>思路二：</strong><br>        对于上述问题，我们可以优化其时间复杂度，在查找数组中是否存在满足目标值的迭代中，我们可以利用哈希表的特点，能够使索引与数据一一对应，这样我们查找目标值时，时间复杂度可以由O(n)变为O(1)(当然是理想状况下，由于hash map还存在冲突等问题，并不能完全达到O(1)的时间，但其效率还是要远远大于O(n))。由于用C编写hashmap较复杂，所以这里我们用Python编写，用其中的’字典’来存储数据，因为字典背后的原理就是一个散列表。在进行迭代并将元素插入到表中的同时(元素不在表中)，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。<br><strong>code：</strong></p><pre><code>class Solution:    def twoSum(self,nums,target):        length = len(nums)        key = {}        for i in range(length):            new_n = target - nums[i];    #用于判断当前值对应的目标元素是否在新字典里            if new_n in key:                return [key[new_n],i]       #目标元素在新字典中，直接返回其下标            if nums[i] not in key:                key[nums[i]] = i            #目标元素不在新字典中，将当前值存储到新字典中，用于后面原字典数据的判断</code></pre><p>复杂度：<br>      因为只使用了一个迭代，故时间复杂度O(n)；同样的，因为用新字典key{}存储已经判断过的值，即我们是通过空间的提升换取时间效率的提升，所以空间复杂度由O(1)变为O(n)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;问题描述：&lt;/strong&gt;&lt;br&gt;        给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，返回的两个下标不能相同，即不能为相同的一个元
      
    
    </summary>
    
      <category term="Programming Thinking" scheme="http://baibing0819.github.io/categories/Programming-Thinking/"/>
    
    
      <category term="求和算法" scheme="http://baibing0819.github.io/tags/%E6%B1%82%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://baibing0819.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>hexo+github搭建个人博客</title>
    <link href="http://baibing0819.github.io/2019/03/08/hexo-github-da-jian-ge-ren-bo-ke/"/>
    <id>http://baibing0819.github.io/2019/03/08/hexo-github-da-jian-ge-ren-bo-ke/</id>
    <published>2019-03-08T08:59:00.000Z</published>
    <updated>2019-03-08T10:09:46.109Z</updated>
    
    <content type="html"><![CDATA[<p>前言：<br>    花了两天时间，总算是搭建了自己的个人博客。基本上跟着网上大神的教程做，大部分很顺利，但还是不可避免的遇到一些小的坑，因此花费了不少的时间，故在此也总结一下自己遇到的问题，若大家遇到相似的问题，可以快速的解决。搭建博客主要是下面三个方面，完成后就可以完美的发博客啦。</p><h3 id="步骤-教程直通车"><a href="#步骤-教程直通车" class="headerlink" title="步骤+教程直通车:"></a><strong>步骤+教程直通车</strong>:</h3><h4 id="1、hexo-github-搭建个人博客"><a href="#1、hexo-github-搭建个人博客" class="headerlink" title="1、hexo + github 搭建个人博客:"></a>1、hexo + github 搭建个人博客:</h4><pre><code>[网址传送门：](https://mp.weixin.qq.com/s?__biz=MzI5NDY1MjQzNA==&amp;mid=2247488956&amp;idx=3&amp;sn=a0c52c1a270269925fc6ea9e84596e10&amp;chksm=ec5ecac1db2943d75368ef598fd22eda6497dbc35e5b8941335d2fc9e44de516bcc470f8e4a2&amp;mpshare=1&amp;scene=1&amp;srcid=0302seoWmMigQ065XCb3qvxP&amp;key=0c5bd8d37f17829348d3918abd80122f9caed41ef7b4beefc679edddb6b35997f0f0ad370cf89dbe6c92ab782f69d7bacc8a7a59f3d7a19fb1069951797c63f67131fb05a0f8ab28ae68db51b144f374&amp;ascene=1&amp;uin=MjY0NTYwMzU0Mw%3D%3D&amp;devicetype=Windows+10&amp;version=62060728&amp;lang=zh_CN&amp;pass_ticket=1UsAPqwJzqsYyPrWZrAjE7b15egEPEQyl1ynzAbdrWvGDxenn7xA694UKAIrWc0V)</code></pre><h4 id="2、选择主题："><a href="#2、选择主题：" class="headerlink" title="2、选择主题："></a>2、选择主题：</h4><p><a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/" target="_blank" rel="noopener">网址传送门：</a></p><h4 id="3、搭建图床："><a href="#3、搭建图床：" class="headerlink" title="3、搭建图床："></a>3、搭建图床：</h4><p><a href="https://www.cnblogs.com/asheng2016/p/9572128.html" target="_blank" rel="noopener">网址传送门：</a><br>    个人就是按照上面的网址教程一步步的安装完成的。现在来说一下我遇到的一些问题…</p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p>1、选择主题并配置后，页面没有任何变化，依旧是原始画面。<br>        是因为从网上下载解压后的主题文件夹名字与_config.yml文件里面的配置不同，必须改为一致的。<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/blogcfg.png" alt><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/docname.png" alt><br>2、按照主题帖创建主题后，出现了博客页面空白的现象。<br>        这个是因为按照教程修改配置时，在改动项冒号后直接写内容，导致页面不显示。_config.yml 文件里所有配置项的内容都需要在其冒号后空一格再写内容。<br>3、想换掉主题 中的照片、logo时，改成一样的名字没有成功。<br>        因为图片的格式与之前的不同，可能你的是a.png，原主题的是a.jpg的，所以和其配置选项中的名字不同，导致换图片失败。<br>4、利用hexo + github搭建好博客后，在git bash 里输入hexo server 启动本地预览（<a href="http://localhost:4000/）发现页面找不到，404错误等。" target="_blank" rel="noopener">http://localhost:4000/）发现页面找不到，404错误等。</a><br>        很有可能4000这个端口被占用，此时可以输入命令 (hexo server -p 5000) 来换一个端口就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前言：&lt;br&gt;    花了两天时间，总算是搭建了自己的个人博客。基本上跟着网上大神的教程做，大部分很顺利，但还是不可避免的遇到一些小的坑，因此花费了不少的时间，故在此也总结一下自己遇到的问题，若大家遇到相似的问题，可以快速的解决。搭建博客主要是下面三个方面，完成后就可以完美
      
    
    </summary>
    
      <category term="Markdown" scheme="http://baibing0819.github.io/categories/Markdown/"/>
    
    
      <category term="Markdown" scheme="http://baibing0819.github.io/tags/Markdown/"/>
    
      <category term="Github" scheme="http://baibing0819.github.io/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>MyFirstBlog</title>
    <link href="http://baibing0819.github.io/2019/03/07/myfirstblog/"/>
    <id>http://baibing0819.github.io/2019/03/07/myfirstblog/</id>
    <published>2019-03-07T01:25:00.000Z</published>
    <updated>2019-03-08T10:09:52.431Z</updated>
    
    <content type="html"><![CDATA[<pre><code>    在hexo+github上的第一个博客，看看效果。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;    在hexo+github上的第一个博客，看看效果。&lt;/code&gt;&lt;/pre&gt;
      
    
    </summary>
    
      <category term="Markdown" scheme="http://baibing0819.github.io/categories/Markdown/"/>
    
    
      <category term="Typora" scheme="http://baibing0819.github.io/tags/Typora/"/>
    
      <category term="Markdown" scheme="http://baibing0819.github.io/tags/Markdown/"/>
    
  </entry>
  
</feed>
