<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>IceBai</title>
  
  <subtitle>WhiteIce</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://baibing0819.github.io/"/>
  <updated>2019-05-22T11:55:45.941Z</updated>
  <id>http://baibing0819.github.io/</id>
  
  <author>
    <name>Ice White</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ubuntu18.04安装Tensorflow-gpu</title>
    <link href="http://baibing0819.github.io/2019/05/22/ubuntu18.04-an-zhuang-tensorflow-gpu/"/>
    <id>http://baibing0819.github.io/2019/05/22/ubuntu18.04-an-zhuang-tensorflow-gpu/</id>
    <published>2019-05-22T03:20:00.000Z</published>
    <updated>2019-05-22T11:55:45.941Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言：</strong><br>学习深度学习，安装框架，本文介绍的是安装Tensorflow-gpu版本，如果你的电脑有NVIDA显卡，那么就可以安装，文章主要介绍如何安装Ubuntu18.04 + Tensorflow-gpu + cuda8.0 + cuDNN6.0。</p><p><strong>一些名词：</strong><br><strong>CUDA</strong>(Compute Unified Device Architecture)，是显卡厂商NVIDIA推出的运算平台。CUDA™是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。<br><strong>NVIDIA cuDNN</strong>是用于深度神经网络的GPU加速库。它强调性能、易用性和低内存开销。NVIDIA cuDNN可以集成到更高级别的机器学习框架中，如加州大学伯克利分校的流行caffe软件。简单的，插入式设计可以让开发人员专注于设计和实现神经网络模型，而不是调整性能，同时还可以在GPU上实现高性能现代并行计算。</p><p><strong>安装过程：</strong><br><strong>一、打开软件更新-&gt;附加驱动，选择nvidia最新确定，然后应用更改。</strong><br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/deeplearning/tensorflow-gpu/8.jpg" alt><br>验证驱动是否安装成功：在应用搜索栏输入NVIDA，找到NVIDIA X Sever Settings并打开</p><p>安装成功！</p><p><strong>二、安装Tensorflow依赖的编译工具bazel</strong><br>1、安装bazel前，需先安装JDK8：<br>sudo apt-get install software-properties-common</p><p>sudo add-apt-repository ppa:webupd8team/java</p><p>sudo apt-get update</p><p>sudo apt-get install openjdk-8-jdk</p><p>安装完成后 验证java版本：java -version<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/deeplearning/tensorflow-gpu/1.jpg" alt><br>2、安装bazel：<br>echo “deb [arch=amd64] <a href="http://storage.googleapis.com/bazel-apt" target="_blank" rel="noopener">http://storage.googleapis.com/bazel-apt</a> stable jdk1.8” | sudo tee /etc/apt/sources.list.d/bazel.list</p><p>sudo apt install curl</p><p>sudo apt-get update </p><p>sudo apt-get install bazel</p><p>sudo apt-get upgrade bazel </p><p><strong>三、安装cuda 8.0</strong><br>1、cuda 8.0 下载地址：<a href="https://developer.nvidia.com/cuda-80-ga2-download-archive" target="_blank" rel="noopener">https://developer.nvidia.com/cuda-80-ga2-download-archive</a><br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/deeplearning/tensorflow-gpu/2.jpg" alt><br>2、下载完成后定位到下载目录，输入命令运行该文件<br>sudo sh cuda_8.0.27_linux.run –override</p><p>注：–override是我在遇到gcc编译器版本过高时的解决办法，下面还是会需要对gcc降级，这里先用此方法处理，此时若遇到错误(在提示信息给出的log文件里可以查看到)：Can’t locate InstallUtils.pm in @INC，参考该博客解决方案：<a href="https://www.brilliantcode.net/1211/ubuntu-install-cuda-error-cant-locate-installutils-pm-in-inc/。" target="_blank" rel="noopener">https://www.brilliantcode.net/1211/ubuntu-install-cuda-error-cant-locate-installutils-pm-in-inc/。</a><br>关键部分：<br>mkdir cuda-8<br>sudo sh cuda_8.0.61_375.26_linux.run –noexec –target cuda-8<br>cp cuda-8/InstallUtils.pm /usr/share/perl5</p><p>3、安装结束后添加环境变量，输入 vim ~/.bashrc<br>export PATH=/usr/local/cuda-8.0/bin:$PATH</p><p>export LD_LIBRARY_PATH=/usr/local/cuda-8.0/lib64:$LD_LIBRARY_PATH</p><p>4、nvcc -V</p><p>如果没有nvcc则安装 sudo apt install nvidia-cuda-toolkit</p><p>nvcc -V</p><p>nvidia-smi<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/deeplearning/tensorflow-gpu/3.jpg" alt></p><p>5、验证cuda8是否安装成功：<br>    进入NVIDIA_CUDA-8.0_Samples目录，执行：make，这里应该会报错，因为cuda8.0不支持gcc 5.0以上的编译器，因此需要降级，把编译器版本降到4.8，降级方法参考博客：<a href="https://blog.csdn.net/qq_31175231/article/details/77774971" target="_blank" rel="noopener">https://blog.csdn.net/qq_31175231/article/details/77774971</a></p><p>关键命令记录(g++只需替换gcc即可)：<br>sudo apt-get install gcc-4.8<br>sudo update-alternatives –install /usr/bin/gcc gcc /usr/bin/gcc-4.8 100<br>sudo update-alternatives –config gcc   （用于验证）<br>gcc –version       （用于验证）</p><p>6、CUDA8.0安装成功测试，<br>进入NVIDIA_CUDA-8.0_Samples目录，执行： sudo make （需等待一段时间）</p><p>结束后进入1_Utilities目录，执行：./deviceQuery/deviceQuery ，结果如下：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/deeplearning/tensorflow-gpu/4.png" alt><br>执行： nvcc -V，结果如下：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/deeplearning/tensorflow-gpu/5.jpg" alt></p><p>四、安装cuDNN6.0<br>下载地址6.0： <a href="https://developer.nvidia.com/rdp/cudnn-archive" target="_blank" rel="noopener">https://developer.nvidia.com/rdp/cudnn-archive</a></p><p>打开终端，定位到下载的文件所在文件夹，依次输入命令：</p><p>tar -xvzf cudnn-8.0-linux-x64-v6.0.tgz<br>sudo cp -P cuda/include/cudnn.h /usr/local/cuda-8.0/include<br>sudo cp -P cuda/lib64/libcudnn* /usr/local/cuda-8.0/lib64</p><p>配置环境变量；<br>sudo vim ~/.bashrc</p><p>添加：<br>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda/lib64:/usr/local/cuda/extras/CUPTI/lib64”<br>export CUDA_HOME=/usr/local/cuda</p><p>export PATH=””$CUDA_HOME/bin:$PATH”</p><p>再执行：source ~/.bashrc</p><p>配置完成！</p><p>五、Tensorflow（GPU）安装 ,输入命令</p><p>pip install <a href="https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow_gpu-1.2.0-cp27-none-linux_x86_64.whl" target="_blank" rel="noopener">https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow_gpu-1.2.0-cp27-none-linux_x86_64.whl</a></p><p>注意：若出现错误：tensorflow-0.5.0-cp27-none-linux_x86_64.whl is not a supported wheel on this platform.<br>解决办法：<br>wget <a href="https://bootstrap.pypa.io/get-pip.py" target="_blank" rel="noopener">https://bootstrap.pypa.io/get-pip.py</a><br>sudo python2.7 get-pip.py<br>sudo python2.7 -m pip install <a href="https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.5.0-cp27-none-linux_x86_64.whl" target="_blank" rel="noopener">https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.5.0-cp27-none-linux_x86_64.whl</a> –default-timeout=1000</p><p>测试：<br>进入python环境，输入：python2.7<br>输入以下代码：<br>import tensorflow as tf</p><p>a=tf.constant([1.0,2.0,3.0],shape=[3],name=’a’)</p><p>b=tf.constant([1.0,2.0,3.0],shape=[3],name=’b’)</p><p>c=a+b</p><p>sess=tf.Session(config=tf.ConfigProto(log_device_placement=True))</p><p>print sess.run(c)<br>效果图如下：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/deeplearning/tensorflow-gpu/6.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;br&gt;学习深度学习，安装框架，本文介绍的是安装Tensorflow-gpu版本，如果你的电脑有NVIDA显卡，那么就可以安装，文章主要介绍如何安装Ubuntu18.04 + Tensorflow-gpu + cuda8.0 + cu
      
    
    </summary>
    
      <category term="DeepLearning" scheme="http://baibing0819.github.io/categories/DeepLearning/"/>
    
    
      <category term="DeepLearning" scheme="http://baibing0819.github.io/tags/DeepLearning/"/>
    
      <category term="tools" scheme="http://baibing0819.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>pycharm的简单配置</title>
    <link href="http://baibing0819.github.io/2019/05/13/pycharm/"/>
    <id>http://baibing0819.github.io/2019/05/13/pycharm/</id>
    <published>2019-05-13T12:20:00.000Z</published>
    <updated>2019-05-13T12:08:53.978Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Pycharm下初次使用的一些配置选项：</strong><br>今天个人在ubuntu下使用pycharm创建自己的第一个python工作环境，遇到一些小的问题，在这里记录下来<br>1、选择编译器：个人安装的是anaconda3+pycharm，所以在这里选择了conda解释器来作为编译器，打开pycharm选择file-&gt;setting,接下来具体配置见图：<br>①点击按钮添加：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/python/interpreter.jpg" alt><br>②选择编译器：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/python/interpreter1.jpg" alt></p><p>2、配置程序模板，<br>我们可以为自己经常创建的文件设置模板，比如为.py文件设置抬头，程序功能、编写日期、作者等信息，这样我们之后创建就不需要做重复的工作了，具体步骤如下：同样的，选择file-&gt;setting，然后作如下配置。<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/python/code_template.jpg" alt><br>效果图如下：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/python/templateview.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Pycharm下初次使用的一些配置选项：&lt;/strong&gt;&lt;br&gt;今天个人在ubuntu下使用pycharm创建自己的第一个python工作环境，遇到一些小的问题，在这里记录下来&lt;br&gt;1、选择编译器：个人安装的是anaconda3+pycharm，所以在这
      
    
    </summary>
    
      <category term="Python" scheme="http://baibing0819.github.io/categories/Python/"/>
    
    
      <category term="pycharm" scheme="http://baibing0819.github.io/tags/pycharm/"/>
    
  </entry>
  
  <entry>
    <title>linnux应用图标及快速启动</title>
    <link href="http://baibing0819.github.io/2019/05/09/desktop/"/>
    <id>http://baibing0819.github.io/2019/05/09/desktop/</id>
    <published>2019-05-09T03:20:00.000Z</published>
    <updated>2019-05-09T08:58:28.387Z</updated>
    
    <content type="html"><![CDATA[<p><strong>ubuntu下为应用设置启动图标</strong><br>在ubuntu系统下，通常会有一些应用程序通过终端来打开，这时候我们希望在图形化桌面创建一个他的快捷方式，从而方便的打开它，这里，来记录一下创建过程。 这里我以为微信网页版应用建立桌面图标为例，其他应用步骤相同.<br>1、首先打开终端，进入目录cd /usr/share/applications<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/linux/indir.jpg" alt><br>2、sudo vim wechat.desktop（注：名字自己取，后缀不要改）<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/linux/desktop.jpg" alt><br>3、打开之后添加以下内容：<br>[Desktop Entry]<br>Name=WeChat<br>Comment=WeChat Client<br>Exec=/存放应用程序的绝对路径/<br>Icon=/存放应用程序图标的绝对路径/<br>Terminal=false<br>Type=Application<br>Categories=Application;<br>Encoding=UTF-8<br>StartupNotify=true<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/linux/desktopcode.jpg" alt></p><p>注意：应用程序和为他设置的图片放在同一文件夹下。完成后保存退出，就能够在应用搜索栏里查找的你设置<br>的应用启动图标了。<br>下面是效果图：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/linux/xiaoguotu.png" alt></p><p><strong>二、为应用设置环境变量—终端快捷启动</strong><br>有时我们也不想设置过多的应用图标，希望能够从终端快速输入软件名字直接启动，这时，我们就可以为其设置环境变量。环境变量的作用就是让用户能够无需cd到可执行应用文件夹下在任意当前目录下可以直接输入应用名字打开。过程如下：<br>1、用vim打开环境变量配置文件： vim ~/.bashrc<br>2、追加环境变量路径(将你要设置的应用的绝对路径加入，见下图内容中的最后一行)：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/linux/path.jpg" alt><br><strong>Tips：</strong><br>在我们能够从终端输入应用名字快速启动，有时候我们发现该应用会占用我们的当前终端，用户无法在做其他操作，直到该应用退出或是重新打开一个终端。这时我们可以使用 &amp; 让应用后台运行，解决无法控制终端问题。例如打开atom，输入 atom &amp;即可。更进一步，如果不限每次都这样输入，我们同样可以写进环境变量文件，即用alias设置别名：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/linux/alias.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;ubuntu下为应用设置启动图标&lt;/strong&gt;&lt;br&gt;在ubuntu系统下，通常会有一些应用程序通过终端来打开，这时候我们希望在图形化桌面创建一个他的快捷方式，从而方便的打开它，这里，来记录一下创建过程。 这里我以为微信网页版应用建立桌面图标为例，其他应
      
    
    </summary>
    
      <category term="Linux" scheme="http://baibing0819.github.io/categories/Linux/"/>
    
    
      <category term="linux tips" scheme="http://baibing0819.github.io/tags/linux-tips/"/>
    
  </entry>
  
  <entry>
    <title>sciencenet1</title>
    <link href="http://baibing0819.github.io/2019/04/24/sciencenet1/"/>
    <id>http://baibing0819.github.io/2019/04/24/sciencenet1/</id>
    <published>2019-04-24T03:20:00.000Z</published>
    <updated>2019-05-09T08:26:55.134Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Clash for linux:</strong><br>1、clash-linux获取地址(选取amd版本即可)： <a href="https://github.com/Dreamacro/clash/releases" target="_blank" rel="noopener">https://github.com/Dreamacro/clash/releases</a><br>2、教程网址：<a href="https://withdewhua.space/2019/01/22/use-clash-linux-in-deepin/" target="_blank" rel="noopener">https://withdewhua.space/2019/01/22/use-clash-linux-in-deepin/</a><br>3、编辑~/.config/clash下的 config.yml文件<br>4、因为没有gui界面，网页管理clash，重新启动 clash-linux 以加载配置文件，可通过 <a href="http://clash.razord.top/" target="_blank" rel="noopener">http://clash.razord.top/</a> 或者 <a href="http://yacd.haishan.me/#/" target="_blank" rel="noopener">http://yacd.haishan.me/#/</a> 进行策略组节点的切换，连接的 ip 和端口根据自己的 config.yml 中的external-controller填写；<br>5、可配合浏览器插件使用，也可以使用系统代理（推荐），系统代理可在控制中心-&gt;网络-&gt;系统代理-&gt;手动处填写（根据自己配置文件里的端口填写）。（例如 个人配置文件ip为127.0.0.1   socks端口为8888 http端口为8889，则在对应位置填写即可）</p><p>Tips：设置启动器图标及自启动 自己找一张图片当作 clash-linux 的图标，可存放在 clash-linux 同一文件夹下； 打开终端，输入sudo nano /usr/share/applications/clash.desktop，然后输入以下内容：</p><p>#以下内容自己根据实际情况编写<br>[Desktop Entry]<br>Name=Wechat<br>Version=0.10.2<br>Comment=A rule-based tunnel in Go<br>Exec=Clash full/path/to/clash-linux<br>Icon=/full/path/to/clash-logo.png Terminal=false<br>Type=Application<br>Categories=Network<br>注意：图片以微信应用为例<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/linux/desktopcode.jpg" alt><br>第二步做好之后启动器里可以找到 clash 了，右键点击后选中开机自动启动。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Clash for linux:&lt;/strong&gt;&lt;br&gt;1、clash-linux获取地址(选取amd版本即可)： &lt;a href=&quot;https://github.com/Dreamacro/clash/releases&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
      <category term="Personal Note" scheme="http://baibing0819.github.io/categories/Personal-Note/"/>
    
    
      <category term="tool" scheme="http://baibing0819.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>sciencenet</title>
    <link href="http://baibing0819.github.io/2019/04/19/sciencenet/"/>
    <id>http://baibing0819.github.io/2019/04/19/sciencenet/</id>
    <published>2019-04-19T03:20:00.000Z</published>
    <updated>2019-04-19T13:26:21.155Z</updated>
    
    <content type="html"><![CDATA[<p>ssr客户端下载：<br><a href="https://github.com/shadowsocksrr/shadowsocksr-csharp/releases" target="_blank" rel="noopener">https://github.com/shadowsocksrr/shadowsocksr-csharp/releases</a><br>节点网站（通过ssr客户端选取）：<br><a href="https://free-ss.site/" target="_blank" rel="noopener">https://free-ss.site/</a></p><p>clushx for window下载:<br><a href="https://github.com/Fndroid/clash_for_windows_pkg" target="_blank" rel="noopener">https://github.com/Fndroid/clash_for_windows_pkg</a><br>节点配置文件：<br><a href="https://api.loxcloud.com/ss/orders/101707/clashSub?port=17069&amp;passwd=VngBvFnH" target="_blank" rel="noopener">https://api.loxcloud.com/ss/orders/101707/clashSub?port=17069&amp;passwd=VngBvFnH</a><br>配置教程：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/net/clash%20for%20win%E9%85%8D%E7%BD%AE.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ssr客户端下载：&lt;br&gt;&lt;a href=&quot;https://github.com/shadowsocksrr/shadowsocksr-csharp/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/sh
      
    
    </summary>
    
      <category term="Personal Note" scheme="http://baibing0819.github.io/categories/Personal-Note/"/>
    
    
      <category term="tool" scheme="http://baibing0819.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>linux中的vim操作</title>
    <link href="http://baibing0819.github.io/2019/03/10/linux-zhong-de-vim-cao-zuo/"/>
    <id>http://baibing0819.github.io/2019/03/10/linux-zhong-de-vim-cao-zuo/</id>
    <published>2019-03-10T03:20:00.000Z</published>
    <updated>2019-04-19T09:36:27.423Z</updated>
    
    <content type="html"><![CDATA[<p>基本命令：<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/linux/vim_cmd.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基本命令：&lt;br&gt;&lt;img src=&quot;https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/linux/vim_cmd.png&quot; alt&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Linux" scheme="http://baibing0819.github.io/categories/Linux/"/>
    
    
      <category term="vim" scheme="http://baibing0819.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>两数之和</title>
    <link href="http://baibing0819.github.io/2019/03/10/liang-shu-zhi-he/"/>
    <id>http://baibing0819.github.io/2019/03/10/liang-shu-zhi-he/</id>
    <published>2019-03-10T03:20:00.000Z</published>
    <updated>2019-03-13T12:19:27.487Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题描述：</strong><br>        给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，返回的两个下标不能相同，即不能为相同的一个元素。<br>示例：<br>        给定 nums = [2, 7, 11, 15], target = 9<br>        因为 nums[0] + nums[1] = 2 + 7 = 9<br>        所以返回 [0, 1]</p><p><strong>思路一（暴力法）：</strong><br>        遍历每个元素 x，并查找是否存在一个值与 target - x 相等的目标元素。显然是需要两个迭代，使用C编写。<br><strong>code:</strong></p><pre><code>int* twoSum(int* nums, int numsSize, int target) {    static int a[2] = {0};    int i,j;    i = j = 0;    for(i = 0;i &lt; numsSize;i++)    {        for(j = i+1;j &lt; numsSize;j++)        {            if(nums[i] + nums[j] == target)            {                a[0] = i;                a[1] = j;                return a;            }        }    }    return 0;}</code></pre><p>复杂度：<br>       时间复杂度：O(n^2)；            空间复杂度：O(1)</p><p><strong>思路二：</strong><br>        对于上述问题，我们可以优化其时间复杂度，在查找数组中是否存在满足目标值的迭代中，我们可以利用哈希表的特点，能够使索引与数据一一对应，这样我们查找目标值时，时间复杂度可以由O(n)变为O(1)(当然是理想状况下，由于hash map还存在冲突等问题，并不能完全达到O(1)的时间，但其效率还是要远远大于O(n))。由于用C编写hashmap较复杂，所以这里我们用Python编写，用其中的’字典’来存储数据，因为字典背后的原理就是一个散列表。在进行迭代并将元素插入到表中的同时(元素不在表中)，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。<br><strong>code：</strong></p><pre><code>class Solution:    def twoSum(self,nums,target):        length = len(nums)        key = {}        for i in range(length):            new_n = target - nums[i];    #用于判断当前值对应的目标元素是否在新字典里            if new_n in key:                return [key[new_n],i]       #目标元素在新字典中，直接返回其下标            if nums[i] not in key:                key[nums[i]] = i            #目标元素不在新字典中，将当前值存储到新字典中，用于后面原字典数据的判断</code></pre><p>复杂度：<br>      因为只使用了一个迭代，故时间复杂度O(n)；同样的，因为用新字典key{}存储已经判断过的值，即我们是通过空间的提升换取时间效率的提升，所以空间复杂度由O(1)变为O(n)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;问题描述：&lt;/strong&gt;&lt;br&gt;        给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，返回的两个下标不能相同，即不能为相同的一个元
      
    
    </summary>
    
      <category term="Programming Thinking" scheme="http://baibing0819.github.io/categories/Programming-Thinking/"/>
    
    
      <category term="求和算法" scheme="http://baibing0819.github.io/tags/%E6%B1%82%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://baibing0819.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>无重复字符的最长子串</title>
    <link href="http://baibing0819.github.io/2019/03/10/wu-chong-fu-zi-fu-de-zui-chang-zi-chuan/"/>
    <id>http://baibing0819.github.io/2019/03/10/wu-chong-fu-zi-fu-de-zui-chang-zi-chuan/</id>
    <published>2019-03-10T03:20:00.000Z</published>
    <updated>2019-03-15T06:24:24.281Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题描述：</strong><br>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p><p>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p><p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p><p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是子串的长度，”pwke” 是一个子序列，不是子串。</p><p><strong>思路一(暴力法)：</strong><br>    要找出无重复的最长子串，我们可以采用最直接的办法，先利用两个迭代给出所有可能的子串组合，然后我们建立一个判断字符串中每个字符是否唯一的函数就可以解决(字符串唯一，则返回true并求其长度。不唯一，则返回false)。其中allUnique()函数，使用集合形式去判断，利用集合元素必须唯一的特性，每当向集合中加入一个字符时，我们先判断其是否存在，若存在，则子串不唯一。遍历结束，就可以得出结论。<br><strong>code：</strong></p><pre><code>class Solution {public:    int lengthOfLongestSubstring(string s) {        int n = s.length();        int ans = 0;        for(int i = 0;i &lt; n;i++)            for(int j = i+1;j &lt;= n ;j++) //注意这里i、j的结束值，共n个字符，j可以取到n是用于allUnique()，这样才能取到所有组合                if(allUnique(s,i,j))                    ans = max(ans,j-i);        return ans;    }public:    bool allUnique(string s,int start,int end)    {        set&lt;char&gt; t;        for(int i =start; i &lt; end;i++)        {            if(t.find(s[i]) == t.end())                t.insert(s[i]);            else                return false;        }        return true;    }};</code></pre><p><strong>时间复杂度：</strong><br> 通过遍历给出所有可能的子串组合的时间复杂度为O(n^2)，而判断子串是否唯一的函数一次遍历需要O(J-I)，故总时间复杂度为O(n^3)；<br>空间复杂度的大小为集合所占用空间的大小，取决于字符串n和最长子串m的大小，为O(min(n,m))。</p><p><strong>思路二(滑动窗口)：</strong><br>    暴力法中，我们会对每一个子串的所有字符进行判读是否存在重复字符，但实际上并非必要。试想一下，假设字符串s的一个子串s[i]~s<a href="下标为 i ~ j-1">j-1</a>已经判断为无重复子串，那么此时我们再判断和这个相关的子串s[i] ~ s[j]，我们只需要判断s[j]这一个字符是否已经存在于s[i]~s[j-1]即可，而不是再对这一个子串的所有字符进行判断。<br>    要检查一个字符是否已经在子字符串中，我们可以检查整个子字符串，这将产生一个复杂度为 O(n^2)的算法，但我们可以做得更好。通过使用HashSet 作为滑动窗口，我们可以用 O(1) 的时间来完成对字符是否在当前的子字符串中的检查。<strong>滑动窗口</strong>是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i, j)（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 [i, j)向右滑动 1 个元素，则它将变为 [i+1, j+1)（左闭，右开）。注意，滑动当然也可以是一侧滑动，即一边动，另一边保持不动，即窗口向右“延伸”。<br>                                            <img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%A4%BA%E6%84%8F.png" alt><br>回到我们的问题，我们使用 HashSet 将字符存储在当前窗口 [i, j)（最初 j = i）中。<br>1、我们向右滑动索引 j，当s[j]不在该窗口中时，我们就将他加入HashSet中(相当于窗口向右延伸)，然后我们继续向右滑动索引j，直到s[j]已经在该窗口中，这个过程中，我们可以得到当前无重复字符的长度；<br>2、二是当s[j]已经在该窗口中时，我们此时需要向右滑动索引 i（即去掉窗口左边的第一个元素，缩小了窗口），然后继续判断s[j]是否存在当前窗口中，重复滑动索引i，直到s[j]不存在当前窗口。原理就是当s[j]存在当前窗口时，那么和这一部分子串相关的最长无重复子串长度值就已经唯一确定了。<br>                                 <img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/%E6%BB%91%E5%8A%A8%E7%B4%A2%E5%BC%952.png" alt="步骤2示意图"><br>3、当我们对所有的索引 i 进行1、2两步操作，我们就可以得到答案。<br><strong>code：</strong></p><pre><code>class Solution {public:    int lengthOfLongestSubstring(string s) {        set&lt;char&gt; set1;        int n = s.length();        int i,j,ans;        i = j = ans = 0;        while(i &lt; n &amp;&amp; j &lt; n)        {            if(set1.find(s[j]) == set1.end()) //集合中不包含该字符串，则插入            {                set1.insert(s[j++]);                ans = max(ans,j-i);            }            else            {                set1.erase(s[i++]);   //集合中包含该元素，则窗口向右滑动            }        }        return ans;    }};</code></pre><p><strong>时间复杂度：</strong><br> 时间复杂度：O(2n) = O(n)，在最糟糕的情况下，每个字符将被 i 和 j 访问两次。空间复杂度：O(min(m, n))，与之前的方法相同。滑动窗口法需要 O(k)的空间，其中 k 表示 Set 的大小。而Set的大小取决于字符串 n 的大小以及字符集/字母 m 的大小。</p><p><strong>思路三(优化的滑动窗口)：</strong><br>    上述的方法最多需要执行 2n 个步骤。事实上，它可以被进一步优化为仅需要 n 个步骤。在上面的步骤2中，我们提到了当出现s[j]存在于集合中时，我们就已经唯一确定了和这一部分子串相关的最长无重复子串长度值。我们上面的做法是通过移动索引 i , 直到窗口不含重复字符。而这一步骤我们是可以优化的。我们是否可以直接移动到那个不含重复字符的位置呢？<br>    方法就是将字符串采用字符到索引的映射，比如用HashMap存储而不是HashSet，这样，我们不断的将给定字符串加入到HashMap时，当遇到要加入的字符存在于HashMap时，我们能够直接定位到重复字符在HashMap的具体位置，而不需要像方法二中一样不断的移动索引 i 来确定位置，这样就实现了直接“跳过窗口”，提高了效率。<br>    优化思路总结：采用HashMap存储，如果 s[j] 在HashMap的 [i, j)范围内存在相同字符(假设重复字符下标在HashMap为k，i &lt;= k &lt;j )，我们不需要逐渐增加 i。 我们可以直接跳过 [i，k ] 范围内的所有元素，并将 i 变为 k+1,即此时的窗口为 [k+1,j)。<br>                                                   <img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/%E4%BC%98%E5%8C%96%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="优化的滑动窗口示意图"><br><strong>code：</strong></p><pre><code>class Solution {public:    int lengthOfLongestSubstring(string s) {        unordered_map&lt;char,int&gt; Elem_LastPos;        int maxLen = 0,curLen = 0;    //curLen用于实时的记录无重复字符串长度        for(int i = 0;i &lt; s.length();i++)        {            //第二个判断是为了防止连续不同字母但重复字符的出现（eg：abba），i-Elem_LastPos[s[i]]一定满足&lt;=上一次的实时长度            if(Elem_LastPos.find(s[i]) != Elem_LastPos.end() &amp;&amp; i-Elem_LastPos[s[i]]&lt;=curLen)                curLen = i-Elem_LastPos[s[i]];            else                curLen += 1;            //不存在            Elem_LastPos[s[i]] = i;    //不存在，则加入到HashMap,存在，则跳过窗口[i,k)            maxLen = maxLen &gt; curLen ? maxLen:curLen;        }        return maxLen;    }};</code></pre><p><strong>时间复杂度：</strong><br>时间复杂度：O(n)，索引 i 将会迭代 n 次。<br>空间复杂度（HashMap）：O(min(m, n)），与之前的方法相同。</p><p><strong>优化思路二：</strong><br>上述的优化方法是采用了HashMap的方法存储，当字符集比较小的时候，我们也可以考虑使用字符集映射的方法，一般的字符集的ASCIII码为0-127，故我们只需一个int a[128]的整数数组来实现字符的映射关系，从而代替map。</p><p><strong>code：</strong></p><pre><code>class Solution {public:    int lengthOfLongestSubstring(string s) {        int n = s.length();        int ans = 0;        int index[128] = {0};        for(int i = 0,j = 0;j &lt; n;j++)        {            i = max(index[s[j]],i);    //判断是否存在（重复），不存在，则继续直接计算长度(j-i+1)。存在，则跳过窗口，即更新最新索引i            ans = max(ans,j-i+1);        //更新长度            index[s[j]] = j + 1;        //表示插入字符集映射表，包括更新重复字符的最新值，为了下一次更新索引i        }        return ans;    }};</code></pre><p><strong>时间复杂度：</strong><br>时间复杂度：O(n)，索引 j 将会迭代 n 次。空间复杂度（Table）：O(m)，m 是字符集的大小。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;问题描述：&lt;/strong&gt;&lt;br&gt;给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: “abcabcbb”&lt;br&gt;输出: 3&lt;br&gt;解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。&lt;br&gt;
      
    
    </summary>
    
      <category term="Programming Thinking" scheme="http://baibing0819.github.io/categories/Programming-Thinking/"/>
    
    
      <category term="leetcode" scheme="http://baibing0819.github.io/tags/leetcode/"/>
    
      <category term="字符串" scheme="http://baibing0819.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>hexo+github搭建个人博客</title>
    <link href="http://baibing0819.github.io/2019/03/08/hexo-github-da-jian-ge-ren-bo-ke/"/>
    <id>http://baibing0819.github.io/2019/03/08/hexo-github-da-jian-ge-ren-bo-ke/</id>
    <published>2019-03-08T08:59:00.000Z</published>
    <updated>2019-03-08T10:09:46.109Z</updated>
    
    <content type="html"><![CDATA[<p>前言：<br>    花了两天时间，总算是搭建了自己的个人博客。基本上跟着网上大神的教程做，大部分很顺利，但还是不可避免的遇到一些小的坑，因此花费了不少的时间，故在此也总结一下自己遇到的问题，若大家遇到相似的问题，可以快速的解决。搭建博客主要是下面三个方面，完成后就可以完美的发博客啦。</p><h3 id="步骤-教程直通车"><a href="#步骤-教程直通车" class="headerlink" title="步骤+教程直通车:"></a><strong>步骤+教程直通车</strong>:</h3><h4 id="1、hexo-github-搭建个人博客"><a href="#1、hexo-github-搭建个人博客" class="headerlink" title="1、hexo + github 搭建个人博客:"></a>1、hexo + github 搭建个人博客:</h4><pre><code>[网址传送门：](https://mp.weixin.qq.com/s?__biz=MzI5NDY1MjQzNA==&amp;mid=2247488956&amp;idx=3&amp;sn=a0c52c1a270269925fc6ea9e84596e10&amp;chksm=ec5ecac1db2943d75368ef598fd22eda6497dbc35e5b8941335d2fc9e44de516bcc470f8e4a2&amp;mpshare=1&amp;scene=1&amp;srcid=0302seoWmMigQ065XCb3qvxP&amp;key=0c5bd8d37f17829348d3918abd80122f9caed41ef7b4beefc679edddb6b35997f0f0ad370cf89dbe6c92ab782f69d7bacc8a7a59f3d7a19fb1069951797c63f67131fb05a0f8ab28ae68db51b144f374&amp;ascene=1&amp;uin=MjY0NTYwMzU0Mw%3D%3D&amp;devicetype=Windows+10&amp;version=62060728&amp;lang=zh_CN&amp;pass_ticket=1UsAPqwJzqsYyPrWZrAjE7b15egEPEQyl1ynzAbdrWvGDxenn7xA694UKAIrWc0V)</code></pre><h4 id="2、选择主题："><a href="#2、选择主题：" class="headerlink" title="2、选择主题："></a>2、选择主题：</h4><p><a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/" target="_blank" rel="noopener">网址传送门：</a></p><h4 id="3、搭建图床："><a href="#3、搭建图床：" class="headerlink" title="3、搭建图床："></a>3、搭建图床：</h4><p><a href="https://www.cnblogs.com/asheng2016/p/9572128.html" target="_blank" rel="noopener">网址传送门：</a><br>    个人就是按照上面的网址教程一步步的安装完成的。现在来说一下我遇到的一些问题…</p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p>1、选择主题并配置后，页面没有任何变化，依旧是原始画面。<br>        是因为从网上下载解压后的主题文件夹名字与_config.yml文件里面的配置不同，必须改为一致的。<br><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/blogcfg.png" alt><img src="https://ice-bai-1258776328.cos.ap-guangzhou.myqcloud.com/docname.png" alt><br>2、按照主题帖创建主题后，出现了博客页面空白的现象。<br>        这个是因为按照教程修改配置时，在改动项冒号后直接写内容，导致页面不显示。_config.yml 文件里所有配置项的内容都需要在其冒号后空一格再写内容。<br>3、想换掉主题 中的照片、logo时，改成一样的名字没有成功。<br>        因为图片的格式与之前的不同，可能你的是a.png，原主题的是a.jpg的，所以和其配置选项中的名字不同，导致换图片失败。<br>4、利用hexo + github搭建好博客后，在git bash 里输入hexo server 启动本地预览（<a href="http://localhost:4000/）发现页面找不到，404错误等。" target="_blank" rel="noopener">http://localhost:4000/）发现页面找不到，404错误等。</a><br>        很有可能4000这个端口被占用，此时可以输入命令 (hexo server -p 5000) 来换一个端口就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前言：&lt;br&gt;    花了两天时间，总算是搭建了自己的个人博客。基本上跟着网上大神的教程做，大部分很顺利，但还是不可避免的遇到一些小的坑，因此花费了不少的时间，故在此也总结一下自己遇到的问题，若大家遇到相似的问题，可以快速的解决。搭建博客主要是下面三个方面，完成后就可以完美
      
    
    </summary>
    
      <category term="Markdown" scheme="http://baibing0819.github.io/categories/Markdown/"/>
    
    
      <category term="Markdown" scheme="http://baibing0819.github.io/tags/Markdown/"/>
    
      <category term="Github" scheme="http://baibing0819.github.io/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>MyFirstBlog</title>
    <link href="http://baibing0819.github.io/2019/03/07/myfirstblog/"/>
    <id>http://baibing0819.github.io/2019/03/07/myfirstblog/</id>
    <published>2019-03-07T01:25:00.000Z</published>
    <updated>2019-03-08T10:09:52.431Z</updated>
    
    <content type="html"><![CDATA[<pre><code>    在hexo+github上的第一个博客，看看效果。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;    在hexo+github上的第一个博客，看看效果。
&lt;/code&gt;&lt;/pre&gt;
      
    
    </summary>
    
      <category term="Markdown" scheme="http://baibing0819.github.io/categories/Markdown/"/>
    
    
      <category term="Typora" scheme="http://baibing0819.github.io/tags/Typora/"/>
    
      <category term="Markdown" scheme="http://baibing0819.github.io/tags/Markdown/"/>
    
  </entry>
  
</feed>
